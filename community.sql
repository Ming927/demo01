/*
 Navicat Premium Data Transfer

 Source Server         : Linux
 Source Server Type    : MySQL
 Source Server Version : 80013
 Source Host           : 121.199.62.135:3306
 Source Schema         : community

 Target Server Type    : MySQL
 Target Server Version : 80013
 File Encoding         : 65001

 Date: 01/11/2020 17:21:51
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment`  (
  `id` bigint(255) NOT NULL AUTO_INCREMENT,
  `parent_id` bigint(255) NOT NULL,
  `question_type` bigint(255) NOT NULL,
  `commentator` bigint(255) NOT NULL,
  `gmt_create` bigint(255) NOT NULL,
  `gmt_modified` bigint(255) NOT NULL,
  `like_count` bigint(255) NULL DEFAULT 0,
  `content` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `comment_count` bigint(255) NULL DEFAULT 0,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 127 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of comment
-- ----------------------------
INSERT INTO `comment` VALUES (117, 173, 1, 29, 1589717500705, 1589717500705, 0, '1', 0);
INSERT INTO `comment` VALUES (118, 152, 1, 29, 1589724536084, 1589724536084, 0, '代码格式', 2);
INSERT INTO `comment` VALUES (119, 118, 2, 29, 1589724556982, 1589724556982, 0, '图片格式', 0);
INSERT INTO `comment` VALUES (120, 158, 1, 30, 1589724794886, 1589724794886, 0, '明白了', 1);
INSERT INTO `comment` VALUES (121, 153, 1, 30, 1589724853818, 1589724853818, 0, '挺直观的', 0);
INSERT INTO `comment` VALUES (122, 152, 1, 30, 1589724885557, 1589724885557, 0, '说得挺好的', 0);
INSERT INTO `comment` VALUES (123, 118, 2, 30, 1589724893835, 1589724893835, 0, '明白了', 0);
INSERT INTO `comment` VALUES (124, 120, 2, 29, 1590718804752, 1590718804752, 0, '111', 0);
INSERT INTO `comment` VALUES (125, 174, 1, 29, 1591151805020, 1591151805020, 0, '有图', 1);
INSERT INTO `comment` VALUES (126, 125, 2, 29, 1591151811028, 1591151811028, 0, '11', 0);

-- ----------------------------
-- Table structure for notification
-- ----------------------------
DROP TABLE IF EXISTS `notification`;
CREATE TABLE `notification`  (
  `id` bigint(255) NOT NULL AUTO_INCREMENT,
  `notifier` bigint(255) NOT NULL,
  `notify_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `notify_title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `receiver` bigint(255) NOT NULL,
  `outer_id` bigint(255) NOT NULL,
  `reply_type` int(2) NOT NULL DEFAULT 0,
  `gmt_create` bigint(255) NOT NULL,
  `status` int(255) NOT NULL DEFAULT 0,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 41 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of notification
-- ----------------------------
INSERT INTO `notification` VALUES (37, 30, '阿明', 'HashMap和HashSet区别', 29, 158, 1, 1589724794895, 1);
INSERT INTO `notification` VALUES (38, 30, '阿明', '传统 HashMap 的缺点', 29, 152, 1, 1589724885564, 1);
INSERT INTO `notification` VALUES (39, 30, '阿明', '传统 HashMap 的缺点', 29, 152, 2, 1589724893842, 0);
INSERT INTO `notification` VALUES (40, 29, '小生阿明', 'HashMap和HashSet区别', 30, 158, 2, 1590718804777, 0);

-- ----------------------------
-- Table structure for question
-- ----------------------------
DROP TABLE IF EXISTS `question`;
CREATE TABLE `question`  (
  `id` bigint(255) NOT NULL AUTO_INCREMENT,
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `description` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL,
  `gmt_create` bigint(255) NULL DEFAULT NULL,
  `gmt_modified` bigint(255) NULL DEFAULT NULL,
  `creator` bigint(255) NULL DEFAULT NULL,
  `comment_count` bigint(255) NULL DEFAULT 0,
  `view_count` bigint(255) NULL DEFAULT 0,
  `like_count` bigint(255) NULL DEFAULT 0,
  `tag` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `avatar_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 175 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of question
-- ----------------------------
INSERT INTO `question` VALUES (143, '点击删除按钮弹出对话框提示是否删除', '```java\r\n<%@ page language=\"java\" import=\"java.util.*\" pageEncoding=\"utf-8\"%>\r\n<%\r\nString path = request.getContextPath();\r\nString basePath = request.getScheme()+\"://\"+request.getServerName()+\":\"+request.getServerPort()+path+\"/\";\r\n%>\r\n\r\n<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">\r\n<html>\r\n  <head>\r\n    <base href=\"<%=basePath%>\">\r\n\r\n    <title>My JSP \'index.jsp\' starting page</title>\r\n    <meta http-equiv=\"pragma\" content=\"no-cache\">\r\n    <meta http-equiv=\"cache-control\" content=\"no-cache\">\r\n    <meta http-equiv=\"expires\" content=\"0\">    \r\n    <meta http-equiv=\"keywords\" content=\"keyword1,keyword2,keyword3\">\r\n    <meta http-equiv=\"description\" content=\"This is my page\">\r\n    <!--\r\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"styles.css\">\r\n    -->\r\n    <script type=\"text/javascript\" src=\"./Jscript/jquery.min.js\"></script>\r\n  </head>\r\n\r\n  <body>\r\n    <input id=\"input\" type=\"button\" value=\"删除\" />\r\n    <script type=\"text/javascript\">\r\n        $().ready(function(){\r\n            $(\"#input\").click(function(){   //点击按钮访问后台servlet\r\n                var r=confirm(\"确定删除吗？\")\r\n                if (r==true)\r\n                {\r\n                    var xhr  = createXmlHttpRequest();\r\n                    xhr.onreadystatechange = function(){\r\n                        if(xhr.readyState == 4){\r\n                            if(xhr.status == 200 || xhr.status == 304){\r\n                                alert(\"aaaa\");\r\n                            }\r\n                        }\r\n                    }   \r\n                    xhr.open(\"GET\",\"servlet/JOptionServlet?time=\" + new Date().getTime());\r\n                    xhr.send(null);\r\n\r\n                }else{\r\n\r\n                }       \r\n\r\n            });     \r\n        });\r\n        function createXmlHttpRequest(){\r\n           var xmlHttp;\r\n           try{    //Firefox, Opera 8.0+, Safari\r\n                   xmlHttp=new XMLHttpRequest();\r\n            }catch (e){\r\n                   try{    //Internet Explorer\r\n                          xmlHttp=new ActiveXObject(\"Msxml2.XMLHTTP\");\r\n                    }catch (e){\r\n                          try{\r\n                                  xmlHttp=new ActiveXObject(\"Microsoft.XMLHTTP\");\r\n                          }catch (e){}  \r\n                   }\r\n            }\r\n           return xmlHttp;\r\n        }\r\n    </script>\r\n  </body>\r\n</html>\r\n```', 1589630035556, 1589630035513, 29, 0, 22, 0, 'java', 'https://avatars2.githubusercontent.com/u/52100840?v=4');
INSERT INTO `question` VALUES (147, '触发器的作用', '触发器是一中特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。', 1589630024413, 1589630035513, 29, 0, 2, 0, 'mysql,intellij-idea', 'https://avatars2.githubusercontent.com/u/52100840?v=4');
INSERT INTO `question` VALUES (148, '什么是存储过程？用什么来调用？', '存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。 调用： 1）可以用一个命令对象来调用存储过程。 2）可以供外部程序调用，比如：java程序', 1589630035413, 1589630035513, 29, 0, 1, 0, 'java,mysql', 'https://avatars2.githubusercontent.com/u/52100840?v=4');
INSERT INTO `question` VALUES (149, '存储过程的优缺点', '优点： 1）存储过程是预编译过的，执行效率高。 2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。 3）安全性高，执行存储过程需要有一定权限的用户。 4）存储过程可以重复使用，可减少数据库开发人员的工作量。 缺点：移植性差', 1589630038122, 1589630035513, 29, 0, 7, 0, 'mysql', 'https://avatars2.githubusercontent.com/u/52100840?v=4');
INSERT INTO `question` VALUES (150, '数据库触发器的简单使用', '比如当我们在做用户模块的表设计的时候，我们建了联用户信息表（t_user）和账号表（t_account），账号表（t_account）用来进行账号的注册 ，密码的修改等操作，而用户表（t_user）则用来存储用户的基本信息（比如：姓名，年龄等），通常我们在 t_user中创建外键（userid）进行关联t_account以保证每个账号下对应一个用户信息。\r\n\r\n当账号（t_account）注册成功后，如何在用户（t_user）中同时添加相应信息以保证数据的实时性和准确性。\r\n\r\n通常我们的做法是，当注册成功  t_account中 insert 一组账号信息 同时在t_user表中相应的insert 一组信息。可以达到此目的。当然这样的做法是没问题的，只是比较麻烦，浪费时间和经历。最主要的是特么的谁没事写那么多sql 干什么，有简单的办法可以做到为什么要这么折腾人。', 1589630038112, 1589630035513, 29, 0, 2, 0, 'mysql', 'https://avatars2.githubusercontent.com/u/52100840?v=4');
INSERT INTO `question` VALUES (151, '那么什么是触发器（trigger）', '触发器（trigger）是SQL server 提供给程序员和数据分析员来保证数据完整性的一种方法，它是与表事件相关的特殊的存储过程，它的执行不是由程序调用，也不是手工启动，而是由事件来触发，比如当对一个表进行操作（ insert，delete， update）时就会激活它执行。触发器经常用于加强数据的完整性约束和业务规则等。 触发器可以从 DBA_TRIGGERS ，USER_TRIGGERS 数据字典中查到。SQL3的触发器是一个能由系统自动执行对数据库修改的语句。\r\n触发器可以查询其他表，而且可以包含复杂的SQL语句。它们主要用于强制服从复杂的业务规则或要求。例如：您可以根据客户当前的帐户状态，控制是否允许插入新订单。\r\n触发器也可用于强制引用完整性，以便在多个表中添加、更新或删除行时，保留在这些表之间所定义的关系。然而，强制引用完整性的最好方法是在相关表中定义主键和外键约束。如果使用数据库关系图，则可以在表之间创建关系以自动创建外键约束。\r\n触发器与存储过程的唯一区别是触发器不能执行EXECUTE语句调用，而是在用户执行Transact-SQL语句时自动触发执行。\r\n好了，介绍完触发器，我们接下来该看看怎么玩它了。这里我们用SQLyog来创建，语法：```\r\n```mysql\r\n    create TRIGGER `jony_keer`.`ins_account` AFTER INSERT\r\n    ON `jony_keer`.`t_account`\r\n    FOR EACH ROW BEGIN\r\n    INSERT INTO `t_user`(`userid`,`cellphone`,`account_psd`)  VALUES   (new.`account_id`,new.`cellphone`,new.`account_psd`);\r\n    END；\r\n//这是我之前练的一套\r\nCREATE TABLE goods(\r\n  gid int(5) NOT NULL,\r\n  name varchar(20) NOT NULL,\r\n  num int(5) DEFAULT NULL,\r\n  PRIMARY KEY (gid)\r\n);\r\n\r\ninsert into goods values(123,\"cat\",50);\r\ninsert into goods values(124,\"dog\",50);\r\ninsert into goods values(125,\"pig\",50);\r\n\r\nCREATE TABLE orders(\r\n	id int(255),\r\n  	gid int(5) NOT NULL,\r\n  	num int(5) DEFAULT NULL,\r\n  	PRIMARY KEY (id)\r\n);\r\n\r\ncreate TRIGGER play\r\nafter insert on orders\r\nfor each row \r\nBEGIN\r\nupdate goods set num=num-new.num where gid=new.gid;\r\nend;\r\n\r\ninsert into orders values(1,123,10);\r\ninsert into orders values(2,124,10)\r\n\r\ncreate TRIGGER play\r\nafter insert on orders\r\nfor each row \r\nBEGIN\r\nupdate goods set num=num-new.num where gid=new.gid;\r\nend;\r\n\r\n\r\ncreate trigger play1\r\nafter delete on orders\r\nfor each row \r\nbegin \r\nupdate goods set num=num+old.num where gid=old.gid;\r\nend;\r\n\r\ndelete from orders where id=2\r\n\r\ninsert into orders values(1,123,10);\r\n\r\ndelete from orders where id=1 \r\n\r\ncreate trigger play2\r\nbefore update on orders\r\nfor each row \r\nbegin \r\nupdate goods set num=num+old.num-new.num where gid=new.gid;\r\nend;\r\n\r\ninsert into orders values(1,123,10); \r\n\r\nupdate orders set num=20 where id=1;\r\n\r\ncreate trigger play3\r\nbefore insert on orders\r\nfor each row\r\nbegin \r\ndeclare lnum int;\r\nselect num into lnum from goods where gid =new.gid ;\r\nif new.num>lnum then set new.num=lnum;\r\nend if;\r\nupdate goods set num=num-new.num where gid=new.gid;\r\nend;\r\n\r\ninsert into orders values(4,123,30);\r\n\r\ndelete from orders where id=4;\r\n\r\nshow triggers;\r\n\r\ndrop trigger play;\r\n\r\ninsert into orders values(5,123,10);\r\n```\r\n', 1589630034513, 1589630035513, 29, 0, 2, 0, 'mysql', 'https://avatars2.githubusercontent.com/u/52100840?v=4');
INSERT INTO `question` VALUES (152, '传统 HashMap 的缺点', 'JDK 1.8 以前 HashMap 的实现是 数组+链表，即使哈希函数取得再好，也很难达到元素百分百均匀分布。\r\n\r\n当 HashMap 中有大量的元素都存放到同一个桶中时，这个桶下有一条长长的链表，这个时候 HashMap 就相当于一个单链表，假如单链表有 n 个元素，遍历的时间复杂度就是 O(n)，完全失去了它的优势。\r\n\r\n针对这种情况，JDK 1.8 中引入了 红黑树（查找时间复杂度为 O(logn)）来优化这个问题。\r\n\r\nHashMap 在 JDK 1.8 中新增的数据结构 – 红黑树\r\n\r\n\r\nJDK 1.8 中 HashMap 中除了链表节点：\r\n```java\r\nstatic class Node<K,V> implements Map.Entry<K,V> {\r\n    //哈希值，就是位置\r\n    final int hash;\r\n    //键\r\n    final K key;\r\n    //值\r\n    V value;\r\n    //指向下一个几点的指针\r\n    Node<K,V> next;\r\n    //...\r\n}\r\n```\r\n还有另外一种节点：TreeNode，它是 1.8 新增的，属于数据结构中的 红黑树（不了解红黑树的同学可以 点击这里了解红黑树）：\r\n```java\r\nstatic final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {\r\n    TreeNode<K,V> parent;  // red-black tree links\r\n    TreeNode<K,V> left;\r\n    TreeNode<K,V> right;\r\n    TreeNode<K,V> prev;    // needed to unlink next upon deletion\r\n    boolean red;\r\n}\r\n```\r\n可以看到就是个红黑树节点，有父亲、左右孩子、前一个元素的节点，还有个颜色值。\r\n\r\n另外由于它继承自 LinkedHashMap.Entry ，而 LinkedHashMap.Entry 继承自 HashMap.Node ，因此还有额外的 6 个属性：\r\n```java\r\n//继承 LinkedHashMap.Entry 的\r\nEntry<K,V> before, after;\r\n\r\n//HashMap.Node 的\r\nfinal int hash;\r\nfinal K key;\r\nV value;\r\nNode<K,V> next;\r\n```\r\nHashMap 中关于红黑树的三个关键参数\r\nHashMap 中有三个关于红黑树的关键参数:\r\n\r\nTREEIFY_THRESHOLD\r\nUNTREEIFY_THRESHOLD\r\nMIN_TREEIFY_CAPACITY\r\n值及作用如下：\r\n\r\n//一个桶的树化阈值\r\n//当桶中元素个数超过这个值时，需要使用红黑树节点替换链表节点\r\n//这个值必须为 8，要不然频繁转换效率也不高\r\nstatic final int TREEIFY_THRESHOLD = 8;\r\n\r\n//一个树的链表还原阈值\r\n//当扩容时，桶中元素个数小于这个值，就会把树形的桶元素 还原（切分）为链表结构\r\n//这个值应该比上面那个小，至少为 6，避免频繁转换\r\nstatic final int UNTREEIFY_THRESHOLD = 6;\r\n\r\n//哈希表的最小树形化容量\r\n//当哈希表中的容量大于这个值时，表中的桶才能进行树形化\r\n//否则桶内元素太多时会扩容，而不是树形化\r\n//为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD\r\nstatic final int MIN_TREEIFY_CAPACITY = 64;\r\n\r\nHashMap 在 JDK 1.8 中新增的操作：桶的树形化 treeifyBin()\r\n在Java 8 中，如果一个桶中的元素个数超过 TREEIFY_THRESHOLD(默认是 8 )，就使用红黑树来替换链表，从而提高速度。\r\n\r\n这个替换的方法叫 treeifyBin() 即树形化。\r\n\r\n//将桶内所有的 链表节点 替换成 红黑树节点\r\nfinal void treeifyBin(Node<K,V>[] tab, int hash) {\r\n    int n, index; Node<K,V> e;\r\n    //如果当前哈希表为空，或者哈希表中元素的个数小于 进行树形化的阈值(默认为 64)，就去新建/扩容\r\n    if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)\r\n        resize();\r\n    else if ((e = tab[index = (n - 1) & hash]) != null) {\r\n        //如果哈希表中的元素个数超过了 树形化阈值，进行树形化\r\n        // e 是哈希表中指定位置桶里的链表节点，从第一个开始\r\n        TreeNode<K,V> hd = null, tl = null; //红黑树的头、尾节点\r\n        do {\r\n            //新建一个树形节点，内容和当前链表节点 e 一致\r\n            TreeNode<K,V> p = replacementTreeNode(e, null);\r\n            if (tl == null) //确定树头节点\r\n                hd = p;\r\n            else {\r\n                p.prev = tl;\r\n                tl.next = p;\r\n            }\r\n            tl = p;\r\n        } while ((e = e.next) != null);  \r\n        //让桶的第一个元素指向新建的红黑树头结点，以后这个桶里的元素就是红黑树而不是链表了\r\n        if ((tab[index] = hd) != null)\r\n            hd.treeify(tab);\r\n    }\r\n}\r\n\r\n\r\n```java\r\nTreeNode<K,V> replacementTreeNode(Node<K,V> p, Node<K,V> next) {\r\nreturn new TreeNode<>(p.hash, p.key, p.value, next);\r\n```\r\n\r\n}\r\n\r\n上述操作做了这些事:\r\n\r\n根据哈希表中元素个数确定是扩容还是树形化\r\n如果是树形化\r\n遍历桶中的元素，创建相同个数的树形节点，复制内容，建立起联系\r\n然后让桶第一个元素指向新建的树头结点，替换桶的链表内容为树形内容\r\n但是我们发现，之前的操作并没有设置红黑树的颜色值，现在得到的只能算是个二叉树。在 最后调用树形节点 hd.treeify(tab) 方法进行塑造红黑树，来看看代码：\r\n\r\n```java\r\n   final void treeify(Node<K,V>[] tab) {\r\n    TreeNode<K,V> root = null;\r\n    for (TreeNode<K,V> x = this, next; x != null; x = next) {\r\n        next = (TreeNode<K,V>)x.next;\r\n        x.left = x.right = null;\r\n        if (root == null) { //头回进入循环，确定头结点，为黑色\r\n            x.parent = null;\r\n            x.red = false;\r\n            root = x;\r\n        }\r\n        else {  //后面进入循环走的逻辑，x 指向树中的某个节点\r\n            K k = x.key;\r\n            int h = x.hash;\r\n            Class<?> kc = null;\r\n            //又一个循环，从根节点开始，遍历所有节点跟当前节点 x 比较，调整位置，有点像冒泡排序\r\n            for (TreeNode<K,V> p = root;;) {\r\n                int dir, ph;        //这个 dir \r\n                K pk = p.key;\r\n                if ((ph = p.hash) > h)  //当比较节点的哈希值比 x 大时， dir 为 -1\r\n                    dir = -1;\r\n                else if (ph < h)  //哈希值比 x 小时 dir 为 1\r\n                    dir = 1;\r\n                else if ((kc == null &&\r\n                          (kc = comparableClassFor(k)) == null) ||\r\n                         (dir = compareComparables(kc, k, pk)) == 0)\r\n                    // 如果比较节点的哈希值、 x \r\n                    dir = tieBreakOrder(k, pk);\r\n\r\n                    //把 当前节点变成 x 的父亲\r\n                    //如果当前比较节点的哈希值比 x 大，x 就是左孩子，否则 x 是右孩子 \r\n                TreeNode<K,V> xp = p;\r\n                if ((p = (dir <= 0) ? p.left : p.right) == null) {\r\n                    x.parent = xp;\r\n                    if (dir <= 0)\r\n                        xp.left = x;\r\n                    else\r\n                        xp.right = x;\r\n                    root = balanceInsertion(root, x);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    moveRootToFront(tab, root);\r\n}\r\n```\r\n\r\n可以看到，将二叉树变为红黑树时，需要保证有序。这里有个双重循环，拿树中的所有节点和当前节点的哈希值进行对比(如果哈希值相等，就对比键，这里不用完全有序），然后根据比较结果确定在树种的位置。\r\n\r\nHashMap 在 JDK 1.8 中新增的操作： 红黑树中添加元素 putTreeVal()\r\n上面介绍了如何把一个桶中的链表结构变成红黑树结构。\r\n\r\n在添加时，如果一个桶中已经是红黑树结构，就要调用红黑树的添加元素方法 putTreeVal()。\r\n\r\n```java\r\nfinal TreeNode<K,V> putTreeVal(HashMap<K,V> map, Node<K,V>[] tab,\r\n                               int h, K k, V v) {\r\n    Class<?> kc = null;\r\n    boolean searched = false;\r\n    TreeNode<K,V> root = (parent != null) ? root() : this;\r\n    //每次添加元素时，从根节点遍历，对比哈希值\r\n    for (TreeNode<K,V> p = root;;) {\r\n        int dir, ph; K pk;\r\n        if ((ph = p.hash) > h)\r\n            dir = -1;\r\n        else if (ph < h)\r\n            dir = 1;\r\n        else if ((pk = p.key) == k || (k != null && k.equals(pk)))  \r\n        //如果当前节点的哈希值、键和要添加的都一致，就返回当前节点（奇怪，不对比值吗？）\r\n            return p;\r\n        else if ((kc == null &&\r\n                  (kc = comparableClassFor(k)) == null) ||\r\n                 (dir = compareComparables(kc, k, pk)) == 0) {\r\n            //如果当前节点和要添加的节点哈希值相等，但是两个节点的键不是一个类，只好去挨个对比左右孩子 \r\n            if (!searched) {\r\n                TreeNode<K,V> q, ch;\r\n                searched = true;\r\n                if (((ch = p.left) != null &&\r\n                     (q = ch.find(h, k, kc)) != null) ||\r\n                    ((ch = p.right) != null &&\r\n                     (q = ch.find(h, k, kc)) != null))\r\n                    //如果从 ch 所在子树中可以找到要添加的节点，就直接返回\r\n                    return q;\r\n            }\r\n            //哈希值相等，但键无法比较，只好通过特殊的方法给个结果\r\n            dir = tieBreakOrder(k, pk);\r\n        }\r\n\r\n        //经过前面的计算，得到了当前节点和要插入节点的一个大小关系\r\n        //要插入的节点比当前节点小就插到左子树，大就插到右子树\r\n        TreeNode<K,V> xp = p;\r\n     //这里有个判断，如果当前节点还没有左孩子或者右孩子时才能插入，否则就进入下一轮循环 \r\n        if ((p = (dir <= 0) ? p.left : p.right) == null) {\r\n            Node<K,V> xpn = xp.next;\r\n            TreeNode<K,V> x = map.newTreeNode(h, k, v, xpn);\r\n            if (dir <= 0)\r\n                xp.left = x;\r\n            else\r\n                xp.right = x;\r\n            xp.next = x;\r\n            x.parent = x.prev = xp;\r\n            if (xpn != null)\r\n                ((TreeNode<K,V>)xpn).prev = x;\r\n            //红黑树中，插入元素后必要的平衡调整操作\r\n            moveRootToFront(tab, balanceInsertion(root, x));\r\n            return null;\r\n        }\r\n    }\r\n}\r\n\r\n//这个方法用于 a 和 b 哈希值相同但是无法比较时，直接根据两个引用的地址进行比较\r\n//这里源码注释也说了，这个树里不要求完全有序，只要插入时使用相同的规则保持平衡即可\r\n static int tieBreakOrder(Object a, Object b) {\r\n    int d;\r\n    if (a == null || b == null ||\r\n        (d = a.getClass().getName().\r\n         compareTo(b.getClass().getName())) == 0)\r\n        d = (System.identityHashCode(a) <= System.identityHashCode(b) ?\r\n             -1 : 1);\r\n    return d;\r\n}\r\n```\r\n\r\n通过上面的代码可以知道，HashMap 中往红黑树中添加一个新节点 n 时，有以下操作：\r\n\r\n从根节点开始遍历当前红黑树中的元素 p，对比 n 和 p 的哈希值；\r\n如果哈希值相等并且键也相等，就判断为已经有这个元素（这里不清楚为什么不对比值）；\r\n如果哈希值就通过其他信息，比如引用地址来给个大概比较结果，这里可以看到红黑树的比较并不是很准确，注释里也说了，只是保证个相对平衡即可；\r\n最后得到哈希值比较结果后，如果当前节点 p 还没有左孩子或者右孩子时才能插入，否则就进入下一轮循环;\r\n插入元素后还需要进行红黑树例行的平衡调整，还有确保根节点的领先地位。\r\nHashMap 在 JDK 1.8 中新增的操作： 红黑树中查找元素 getTreeNode()\r\nHashMap 的查找方法是 get():', 1589630035518, 1589630035513, 29, 2, 11, 0, 'java', 'https://avatars2.githubusercontent.com/u/52100840?v=4');
INSERT INTO `question` VALUES (153, 'ArrayList和LinkList的区别', '#### ArrayList（数组结构）：\r\n\r\n        优点：get和set调用花费常数时间，也就是查询的速度快；\r\n    \r\n        缺点：新项的插入和现有项的删除代价昂贵，也就是添加删除的速度慢\r\n\r\n#### LinkedList（链表结构）：\r\n\r\n        优点：新项的插入和和现有项的删除开销很小，即添加和删除的速度快\r\n    \r\n        缺点：对get和set的调用花费昂贵，不适合做查询\r\n\r\n ', 1589630035519, 1589630035513, 30, 1, 4, 0, 'java', 'https://avatars2.githubusercontent.com/u/57753360?v=4');
INSERT INTO `question` VALUES (154, 'Collection接口的remove()方法和Iterator接口的remove()方法区别', '①性能方面\r\nCollection的remove方法必须首先找出要被删除的项，找到该项的位置采用的是单链表结构查询，单链表查询效率比较低，需要从集合中一个一个遍历才能找到该对象；\r\nIterator的remove方法结合next()方法使用，比如集合中每隔一项删除一项，Iterator的remove()效率更高\r\n\r\n②容错方面\r\n在使用Iterator遍历时，如果使用Collection的remove则会报异常，会出现ConcurrentModificationException，因为集合中对象的个数会改变而Iterator 内部对象的个数不会，不一致则会出现该异常\r\n在使用Iterator遍历时，不会报错，因为iterator内部的对象个数和原来集合中对象的个数会保持一致', 1589630045532, 1589630032213, 30, 0, 7, 0, 'java', 'https://avatars2.githubusercontent.com/u/57753360?v=4');
INSERT INTO `question` VALUES (155, 'Array与ArrayList有什么区别', '①Array是Java中的数组，声明数组有三种方式\r\n\r\n在定义一个数组的时候，必须指定这个数组的数据类型及数组的大小，也就是说数组中存放的元素个数固定并且类型一样\r\n\r\n②ArrayList是动态数组,也就是数组的复杂版本，它可以动态的添加和删除元素，被称为”集合“，在不使用泛型的情况下，这个list是可以添加进不同类型的元素的，而且arraylist是可以不用指定长度的。在使用泛型时，我们就只能添加一种类型的数据了', 1589630035263, 1589630033513, 29, 0, 1, 0, 'java', 'https://avatars2.githubusercontent.com/u/52100840?v=4');
INSERT INTO `question` VALUES (156, '怎将一个数组转成List，有什么方法', '①数组转list，可以使用Arrays.asList(数组)\r\n\r\n②List转数组，使用list.toArray()', 1589630035523, 1589630035313, 29, 0, 1, 0, 'java', 'https://avatars2.githubusercontent.com/u/52100840?v=4');
INSERT INTO `question` VALUES (157, 'HashSet、TreeSet、LinkedHashSet区别？', '可以从集合的使用场合回答面试官\r\n\r\n①.需要速度快的集合，使用HashSet\r\n\r\n②.需要集合有排序功能，使用TreeSet\r\n\r\n③.需要按照插入的顺序存储集合，使用LinkedHashSet', 1589630030212, 1589630035513, 30, 0, 3, 0, 'java', 'https://avatars2.githubusercontent.com/u/57753360?v=4');
INSERT INTO `question` VALUES (158, 'HashMap和HashSet区别', 'a. HashMap实现了Map接口，HashSet实现了Set接口\r\n\r\nb.HashMap存储键值对，HashSet存储对象\r\n\r\nc.HashMap调用put()向map中添加元素，HashSet调用add()像set中添加元素\r\n\r\nd.HashMap使用Key计算hashcode,HashMap使用成员计算Hashcode\r\n\r\nHashMap相对于HashSet较快，因为它是使用唯一的键获取对象\r\n\r\nHashSet较HashMap来说比较慢', 1589630035862, 1589630035413, 29, 1, 9, 0, 'java', 'https://avatars2.githubusercontent.com/u/52100840?v=4');
INSERT INTO `question` VALUES (159, 'HashMap的实现原理', '通过put和get存储和获取对象，存储对象时，我们将K/V传给put方法时，它调用hashcode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量。获取对象时，我们将K传递给get，他调用hashcode计算hash从而得到bucket位置，并进一步调用equals()方法确认键值对。', 1589630038202, 1589630035513, 29, 0, 6, 0, 'java,intellij-idea', 'https://avatars2.githubusercontent.com/u/52100840?v=4');
INSERT INTO `question` VALUES (160, 'List、Set、Map之间的区别', 'List和Set都继承Collection，但是Map不是Collection的子接口。\r\n\r\nList :	可以允许重复的元素   可以插入多个null元素		有序的容器，插入的顺序和输出的顺序一样\r\n\r\nSet :  	不允许重复元素	只允许一个null元素		无序容器\r\n\r\nMap:	键值对存储，键必须唯一，但是值可以重复	键只允许一个null,值可以允许有多个null      无序容器', 1589630033513, 1589630035513, 29, 0, 1, 0, 'java,github,intellij-idea', 'https://avatars2.githubusercontent.com/u/52100840?v=4');
INSERT INTO `question` VALUES (162, 'java的基本类与包装类', '#### 原始类型       包装类       原始类型所占的字节数  \r\n\r\n short              Short               	 2个字节             \r\n int     			Integer   				4个字节\r\n long   			Long    				 8个字节\r\n float  			 Float   				 4个字节\r\n double  		Double 				 8个字节\r\n byte    			Byte    				 1个字节\r\n char   			Character  			2个字节\r\n boolean	 Boolean 				这个试编译环境而定', 1589630032513, 1589630035513, 30, 0, 2, 0, 'java', 'https://avatars2.githubusercontent.com/u/57753360?v=4');
INSERT INTO `question` VALUES (163, '八种类型默认值', '基本类型　　默认值\r\n\r\nbyte　　　　　 0\r\n\r\nint 　　　　  0\r\n\r\nshort          0 \r\n\r\nlong 　　  　0L\r\n\r\ndouble 　　  0.0d\r\n\r\nfloat　　　　　 0.0f\r\n\r\nchar　　　　  \'\\u0000\'　\r\n\r\nboolean　　　　false', 1589630039513, 1589630035513, 30, 0, 4, 0, 'java', 'https://avatars2.githubusercontent.com/u/57753360?v=4');
INSERT INTO `question` VALUES (164, '基本数据类型和包装类型有什么区别', '1、包装类是对象，拥有方法和字段，对象的调用都是通过引用对象的地址，基本类型不是\r\n2、包装类型是引用的传递，基本类型是值的传递\r\n3、声明方式不同，基本数据类型不需要new关键字，而包装类型需要new在堆内存中进行new来分配内存空间\r\n4、存储位置不同，基本数据类型直接将值保存在值栈中，而包装类型是把对象放在堆中，然后通过对象的引用来调用他们\r\n5、初始值不同，eg： int的初始值为 0 、boolean的初始值为false 而包装类型的初始值为null\r\n6、使用方式不同，基本数据类型直接赋值使用就好 ，而包装类型是在集合如 coolection Map时会使用', 1589630036513, 1589630035513, 30, 0, 0, 0, 'java', 'https://avatars2.githubusercontent.com/u/57753360?v=4');
INSERT INTO `question` VALUES (165, '基本类型和包装类型的区别', '01、包装类型可以为 null，而基本类型不可以\r\n别小看这一点区别，它使得包装类型可以应用于 POJO 中，而基本类型则不行。\r\n\r\nPOJO 是什么呢？这里稍微说明一下。\r\n\r\nPOJO 的英文全称是 Plain Ordinary Java Object，翻译一下就是，简单无规则的 Java 对象，只有属性字段以及 setter 和 getter 方法，示例如下。\r\n\r\n```java\r\nclass Writer {\r\n	private Integer age;\r\n	private String name;\r\n	public Integer getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(Integer age) {\r\n        this.age = age;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public void setName(String name) {\r\n        this.name = name;\r\n    }\r\n}\r\n```\r\n\r\n和 POJO 类似的，还有数据传输对象 DTO（Data Transfer Object，泛指用于展示层与服务层之间的数据传输对象）、视图对象 VO（View Object，把某个页面的数据封装起来）、持久化对象 PO（Persistant Object，可以看成是与数据库中的表映射的 Java 对象）。\r\n\r\n那为什么 POJO 的属性必须要用包装类型呢？\r\n\r\n《阿里巴巴 Java 开发手册》上有详细的说明，我们来大声朗读一下（预备，起）。\r\n\r\n数据库的查询结果可能是 null，如果使用基本类型的话，因为要自动拆箱（将包装类型转为基本类型，比如说把 Integer 对象转换成 int 值），就会抛出 NullPointerException 的异常。\r\n\r\n02、包装类型可用于泛型，而基本类型不可以\r\n泛型不能使用基本类型，因为使用基本类型时会编译出错。\r\n\r\nList<int> list = new ArrayList<>(); // 提示 Syntax error, insert \"Dimensions\" to complete ReferenceType\r\nList<Integer> list = new ArrayList<>();\r\n\r\n为什么呢？因为泛型在编译时会进行类型擦除，最后只保留原始类型，而原始类型只能是 Object 类及其子类——基本类型是个特例。\r\n\r\n03、基本类型比包装类型更高效\r\n基本类型在栈中直接存储的具体数值，而包装类型则存储的是堆中的引用。\r\n\r\n很显然，相比较于基本类型而言，包装类型需要占用更多的内存空间。假如没有基本类型的话，对于数值这类经常使用到的数据来说，每次都要通过 new 一个包装类型就显得非常笨重。\r\n\r\n03、两个包装类型的值可以相同，但却不相等\r\n两个包装类型的值可以相同，但却不相等——这句话怎么理解呢？来看一段代码就明明白白了。\r\n\r\n~~~java\r\nInteger chenmo = new Integer(10);\r\nInteger wanger = new Integer(10);\r\n\r\nSystem.out.println(chenmo == wanger); // false\r\nSystem.out.println(chenmo.equals(wanger )); // true\r\n~~~\r\n\r\n\r\n\r\n两个包装类型在使用“==”进行判断的时候，判断的是其指向的地址是否相等。chenmo 和 wanger 两个变量使用了 new 关键字，导致它们在“”的时候输出了 false。\r\n\r\n而 chenmo.equals(wanger) 的输出结果为 true，是因为 equals 方法内部比较的是两个 int 值是否相等。源码如下。\r\n\r\n```java\r\nprivate final int value;\r\n\r\npublic int intValue() {\r\n    return value;\r\n}\r\npublic boolean equals(Object obj) {\r\n    if (obj instanceof Integer) {\r\n        return value == ((Integer)obj).intValue();\r\n    }\r\n    return false;\r\n}\r\n```\r\n\r\n\r\n\r\n瞧，虽然 chenmo 和 wanger 的值都是 10，但他们并不相等。换句话说就是：将“==”操作符应用于包装类型比较的时候，其结果很可能会和预期的不符。\r\n\r\n04、自动装箱和自动拆箱\r\n既然有了基本类型和包装类型，肯定有些时候要在它们之间进行转换。把基本类型转换成包装类型的过程叫做装箱（boxing）。反之，把包装类型转换成基本类型的过程叫做拆箱（unboxing）。\r\n\r\n在 Java SE5 之前，开发人员要手动进行装拆箱，比如说：\r\n\r\n```java\r\nInteger chenmo = new Integer(10);  // 手动装箱\r\nint wanger = chenmo.intValue();  // 手动拆箱\r\n```\r\n\r\nJava SE5 为了减少开发人员的工作，提供了自动装箱与自动拆箱的功能。\r\n\r\n```java\r\nInteger chenmo  = 10;  // 自动装箱\r\nint wanger = chenmo;   // 自动拆箱\r\n```\r\n\r\n上面这段代码使用 JAD 反编译后的结果如下所示：\r\n\r\n```java\r\nInteger chenmo = Integer.valueOf(10);\r\nint wanger = chenmo.intValue();\r\n```\r\n\r\n也就是说，自动装箱是通过 Integer.valueOf() 完成的；自动拆箱是通过 Integer.intValue() 完成的。理解了原理之后，我们再来看一道老马当年给我出的面试题。\r\n\r\n1.基本类型和包装类型\r\n\r\n```java\r\nint a = 100;\r\nInteger b = 100;\r\nSystem.out.println(a == b);\r\n```\r\n\r\n基本类型和包装类型进行 == 比较，这时候 b 会自动拆箱，直接和 a 比较值，所以结果为 true。\r\n\r\n 2.两个包装类型\r\n\r\n```java\r\nInteger c = 100;\r\nInteger d = 100;\r\nSystem.out.println(c == d);\r\n```\r\n\r\n两个包装类型都被赋值为了 100，这时候会进行自动装箱，那 == 的结果会是什么呢？\r\n\r\n我们之前的结论是：将“==”操作符应用于包装类型比较的时候，其结果很可能会和预期的不符。那结果是 false？但这次的结果却是 true，是不是感觉很意外？\r\n\r\n3.\r\n\r\n```java\r\nc = 200;\r\nd = 200;\r\nSystem.out.println(c == d);\r\n```\r\n\r\n两个包装类型重新被赋值为了 200，这时候仍然会进行自动装箱，那 == 的结果会是什么呢？\r\n\r\n吃了第二段代码的亏后，是不是有点怀疑人生了，这次结果是 false 。\r\n\r\n之前我们已经知道了，自动装箱是通过 Integer.valueOf() 完成的，那我们就来看看这个方法的源码吧。\r\n\r\n```java\r\npublic static Integer valueOf(int i) {\r\n    if (i >= IntegerCache.low && i <= IntegerCache.high)\r\n        return IntegerCache.cache[i + (-IntegerCache.low)];\r\n    return new Integer(i);\r\n}\r\n```\r\n\r\n难不成是 IntegerCache 在作怪？你猜对了！\r\n\r\n\r\n\r\n```java\r\nprivate static class IntegerCache {\r\n    static final int low = -128;\r\n    static final int high;\r\n    static final Integer cache[];\r\n\r\n	static {\r\n        // high value may be configured by property\r\n        int h = 127;\r\n        int i = parseInt(integerCacheHighPropValue);\r\n        i = Math.max(i, 127);\r\n        h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\r\n        high = h;\r\n\r\n        cache = new Integer[(high - low) + 1];\r\n        int j = low;\r\n        for(int k = 0; k < cache.length; k++)\r\n            cache[k] = new Integer(j++);\r\n\r\n        // range [-128, 127] must be interned (JLS7 5.1.7)\r\n        assert IntegerCache.high >= 127;\r\n	}\r\n}\r\n```\r\n\r\n大致瞟一下这段代码你就全明白了。-128 到 127 之间的数会从 IntegerCache 中取，然后比较，所以第二段代码（100 在这个范围之内）的结果是 true，而第三段代码（200 不在这个范围之内，所以 new 出来了两个 Integer 对象）的结果是 false。\r\n\r\n看完上面的分析之后，我希望大家记住一点：当需要进行自动装箱时，如果数字在 -128 至 127 之间时，会直接使用缓存中的对象，而不是重新创建一个对象。\r\n\r\n自动装拆箱是一个很好的功能，大大节省了我们开发人员的精力，但也会引发一些麻烦，比如下面这段代码，性能就很差。\r\n\r\n```java\r\nlong t1 = System.currentTimeMillis();\r\nLong sum = 0L;\r\nfor (int i = 0; i < Integer.MAX_VALUE;i++) {\r\n    sum += i;\r\n}\r\nlong t2 = System.currentTimeMillis();        \r\nSystem.out.println(t2-t1);\r\n```\r\n\r\nsum 由于被声明成了包装类型 Long 而不是基本类型 long，所以 sum += i 进行了大量的拆装箱操作（sum 先拆箱和 i 相加，然后再装箱赋值给 sum），导致这段代码运行完花费的时间足足有 2986 毫秒；如果把 sum 换成基本类型 long，时间就仅有 554 毫秒，完全不一个等量级啊。\r\n\r\n5.包装类是对象，对象是存放在堆里，基本类型存放在栈里', 1589630035412, 1589630035513, 29, 0, 1, 0, 'java,intellij-idea', 'https://avatars2.githubusercontent.com/u/52100840?v=4');
INSERT INTO `question` VALUES (166, 'String是最基本的数据类型吗?', 'String是类类型，不是基本类型。\r\n[基本类型](https://how2j.cn/k/variable/variable-type/259.html) 有八种\r\n这八种基本类型分别是：\r\n整型 （4种：int,short,byte,long）\r\n字符型 （1种）(char)\r\n浮点型 （2种）(double,float)\r\n布尔型（1种）(boolean)', 1589630035578, 1589630035513, 29, 0, 1, 0, 'java', 'https://avatars2.githubusercontent.com/u/52100840?v=4');
INSERT INTO `question` VALUES (167, 'int 和 Integer 有什么区别？', 'int 是基本类型32位长度的整数\r\n\r\nInteger 是类类型，是int的[封装类](https://how2j.cn/k/number-string/number-string-wrap/22.html)\r\n\r\nint和Integer之间可以通过[自动装箱](https://how2j.cn/k/number-string/number-string-wrap/22.html#step675) [自动拆箱](https://how2j.cn/k/number-string/number-string-wrap/22.html#step676) 互相转换\r\n\r\n', 1589630035413, 1589630035513, 30, 0, 0, 0, 'node.js,java', 'https://avatars2.githubusercontent.com/u/57753360?v=4');
INSERT INTO `question` VALUES (168, 'String 和StringBuffer的区别？', 'String是[immutable](https://how2j.cn/k/number-string/number-string-string/324.html#step702)的,其内容一旦创建好之后，就不可以发生改变。\r\nStringBuffer 是可以变长的，内容也可以发生改变\r\n改变的原理是StringBuffer内部采用了字符数组存放数据，在需要增加长度的时候，创建新的数组，并且把原来的数据复制到新的数组这样的办法来实现。\r\n更多细节可以参考 模仿StringBuffer的 [MyStringBuffer](https://how2j.cn/k/number-string/number-string-mystringbuilder/331.html) 类是如何实现的。', 1589630035535, 1589630035513, 30, 0, 6, 0, 'java', 'https://avatars2.githubusercontent.com/u/57753360?v=4');
INSERT INTO `question` VALUES (169, '数据库索引的优点和缺点', '##### 优点：\r\n\r\n①通过创建索引,可以在查询的过程中,提高系统的性能\r\n\r\n②通过创建唯一性索引,可以保证数据库表中每一行数据的唯一性\r\n\r\n③在使用分组和排序子句进行数据检索时,可以减少查询中分组和排序的时间\r\n\r\n创建索引可以大大提高系统的性能。\r\n第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。\r\n第二，可以大大加快 数据的检索速度，这也是创建索引的最主要的原因。\r\n第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。\r\n第四，在使用分组和排序 子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。\r\n第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。\r\n\r\n#### 缺点：\r\n\r\n①创建索引和维护索引要耗费时间,而且时间随着数据量的增加而增大\r\n\r\n②索引需要占用物理空间,如果要建立聚簇索引,所需要的空间会更大\r\n\r\n③在对表中的数据进行增加删除和修改时需要耗费较多的时间,因为索引也要动态地维护\r\n\r\n第一，创建索引和维护索引要耗费时间，这种时间随着数据 量的增加而增加。\r\n第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。\r\n第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。', 1589630025529, 1589630035513, 30, 0, 2, 0, 'mysql', 'https://avatars2.githubusercontent.com/u/57753360?v=4');
INSERT INTO `question` VALUES (170, '应该在哪些列上创建索引', '①经常需要搜索的列上\r\n\r\n②作为主键的列上\r\n\r\n③经常用在连接的列上,这些列主要是一些外键,可以加快连接的速度\r\n\r\n④经常需要根据范围进行搜索的列上\r\n\r\n⑤经常需要排序的列上\r\n\r\n⑥经常使用在where子句上面的列上\r\n\r\n在经常需要搜索的列上，可以加快搜索的速度；\r\n在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；\r\n在经常用在连接的列上，这 些列主要是一些外键，可以加快连接的速度；\r\n在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；\r\n在经常需要排序的列上创 建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；\r\n在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。', 1589630035539, 1589630035513, 30, 0, 1, 0, 'mysql', 'https://avatars2.githubusercontent.com/u/57753360?v=4');
INSERT INTO `question` VALUES (171, '不应该在哪些列上创建索引', '①查询中很少用到的列\r\n\r\n②对于那些具有很少数据值的列.比如人事表的性别列,bit数据类型的列\r\n\r\n③对于那些定义为text,image的列.因为这些列的数据量相当大\r\n\r\n④当对修改性能的要求远远大于搜索性能时.因为当增加索引时,会提高搜索性能,但是会降低修改性能', 1589630035565, 1589630035513, 29, 0, 0, 0, 'mysql', 'https://avatars2.githubusercontent.com/u/52100840?v=4');
INSERT INTO `question` VALUES (172, '不应该创建索引的的这些列具有下列特点：', '第一，对于那些在查询中很少使用或者参考的列不应该创建索引。这是因 为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。\r\n第二，对于那 些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比 例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。\r\n第三，对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。\r\n第四，当修改性能远远大于检索性能时，不应该创建索 引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因 此，当修改性能远远大于检索性能时，不应该创建索引。', 1589630035527, 1589630035513, 30, 0, 0, 0, 'mysql', 'https://avatars2.githubusercontent.com/u/57753360?v=4');
INSERT INTO `question` VALUES (173, '什么是 Spring Boot', '什么是 Spring Boot？\r\nSpringBoot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。\r\n\r\n更多 Spring Boot 详细介绍请看这篇文章《什么是Spring Boot?》。\r\n\r\n \r\n\r\n为什么要用 Spring Boot？\r\nSpring Boot 优点非常多，如：\r\n\r\n一、独立运行\r\n\r\nSpring Boot而且内嵌了各种servlet容器，Tomcat、Jetty等，现在不再需要打成war包部署到容器中，Spring Boot只要打成一个可执行的jar包就能独立运行，所有的依赖包都在一个jar包内。\r\n\r\n二、简化配置\r\n\r\nspring-boot-starter-web启动器自动依赖其他组件，简少了maven的配置。\r\n\r\n\r\n\r\n三、自动配置\r\n\r\nSpring Boot能根据当前类路径下的类、jar包来自动配置bean，如添加一个spring-boot-starter-web启动器就能拥有web的功能，无需其他配置。\r\n\r\n四、无代码生成和XML配置\r\n\r\nSpring Boot配置过程中无代码生成，也无需XML配置文件就能完成所有配置工作，这一切都是借助于条件注解完成的，这也是Spring4.x的核心功能之一。\r\n\r\n五、应用监控\r\n\r\nSpring Boot提供一系列端点可以监控服务及应用，做健康检测。\r\n\r\n\r\nSpring Boot 的核心配置文件有哪几个？它们的区别是什么？\r\nSpring Boot 中有以下两种配置文件：\r\n\r\nbootstrap (.yml 或者 .properties)\r\n\r\napplication (.yml 或者 .properties)\r\n\r\nbootstrap/ application 的区别：\r\n\r\nSpring Cloud 构建于 Spring Boot 之上，在 Spring Boot 中有两种上下文，一种是 bootstrap,，另外一种是 application,，bootstrap 是应用程序的父上下文，也就是说 bootstrap 加载优先于 applicaton。bootstrap 主要用于从额外的资源来加载配置信息，还可以在本地外部配置文件中解密属性。这两个上下文共用一个环境，它是任何Spring应用程序的外部属性的来源。bootstrap 里面的属性会优先加载，它们默认也不能被本地相同配置覆盖。\r\n\r\n因此，对比 application 配置文件，bootstrap 配置文件具有以下几个特性：\r\n\r\nboostrap 由父 ApplicationContext 加载，比 applicaton 优先加载\r\n\r\nboostrap 里面的属性不能被覆盖\r\n\r\nbootstrap/ application 的应用场景：\r\n\r\napplication 配置文件这个容易理解，主要用于 Spring Boot 项目的自动化配置。\r\n\r\nbootstrap 配置文件有以下几个应用场景：\r\n\r\n使用 Spring Cloud Config 配置中心时，这时需要在 bootstrap 配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息；\r\n\r\n一些固定的不能被覆盖的属性\r\n\r\n一些加密/解密的场景。\r\n\r\n \r\n\r\nSpring Boot 的配置文件有哪几种格式？它们有什么区别？\r\n.properties 和 .yml，它们的区别主要是书写格式不同。\r\n\r\n1).properties\r\n\r\napp.user.name = javastack\r\n2).yml\r\n\r\napp:\r\n  user:\r\n    name: javastack\r\n另外，.yml 格式不支持 @PropertySource 注解导入配置。\r\n\r\n \r\n\r\nSpring Boot 的核心注解是哪个？它主要由哪几个注解组成的？\r\n启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：\r\n\r\n@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。\r\n\r\n@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。\r\n\r\n@ComponentScan：Spring组件扫描。\r\n\r\n \r\n\r\n开启 Spring Boot 特性有哪几种方式？\r\n有以下两种方式：\r\n\r\n1. 继承spring-boot-starter-parent项目\r\n\r\n<parent>  \r\n<groupId>org.springframework.boot</groupId>   \r\n<artifactId>spring-boot-starter-parent</artifactId>\r\n<version>1.5.6.RELEASE</version>\r\n</parent>\r\n\r\n2. 导入spring-boot-dependencies项目依赖\r\n\r\n<dependencyManagement>\r\n    <dependencies>\r\n        <dependency>\r\n            <groupId>org.springframework.boot</groupId>\r\n            <artifactId>spring-boot-dependencies</artifactId>\r\n            <version>1.5.6.RELEASE</version>\r\n            <type>pom</type>\r\n            <scope>import</scope>\r\n        </dependency>\r\n    <dependencies>\r\n</dependencyManagement>\r\nSpring Boot依赖注意点：\r\n\r\n1. 属性覆盖只对继承有效\r\n\r\nSpring Boot依赖包里面的组件的版本都是和当前Spring Boot绑定的，如果要修改里面组件的版本，只需要添加如下属性覆盖即可，但这种方式只对继承有效，导入的方式无效。\r\n\r\n<properties>\r\n    <slf4j.version>1.7.25<slf4j.version>\r\n</properties>\r\n如果导入的方式要实现版本的升级，达到上面的效果，这样也可以做到，把要升级的组件依赖放到Spring Boot之前。\r\n\r\n\r\n\r\n需要注意，要修改Spring Boot的依赖组件版本可能会造成不兼容的问题。\r\n\r\n \r\n\r\nSpring Boot 需要独立的容器运行吗？\r\n可以不需要，内置了 Tomcat/Jetty 等容器。\r\n\r\n \r\n\r\n运行 Spring Boot 有哪几种方式？\r\n1）打包用命令或者放到容器中运行\r\n\r\n2）用 Maven/Gradle 插件运行\r\n\r\n3）直接执行 main 方法运行\r\n\r\n \r\n\r\nSpring Boot 自动配置原理是什么？\r\nSpring Boot的自动配置注解是@EnableAutoConfiguration， 从上面的@Import的类可以找到下面自动加载自动配置的映射。\r\n\r\norg.springframework.core.io.support.SpringFactoriesLoader.loadFactoryNames(Class<?>, ClassLoader)\r\npublic static List<String> loadFactoryNames(Class<?> factoryClass,ClassLoader classLoader){\r\n\r\n		String factoryClassName = factoryClass.getName();\r\n		try{\r\n			Enumeration<URL> urls = (classLoader!=null?classLoader.getResources(FACTORIES_RESOURCE_LOCATION):lassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));\r\n			\r\n			List<String> result = new ArrayList<String>();\r\n	 \r\n			while(urls.hasMoreElements()){\r\n					URL url = urls.nextElement();\r\n					Properties properties = PropertiesLoaderUtils.loadProperties(new UrlResource(url));\r\n					String factoryClassNames = properties.getProperty(factoryClassName);\r\n					result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));\r\n					\r\n			}\r\n			return result;\r\n		}catch(IOException ex){\r\n			\r\n			throw new IllegalArgumentException(\"Unable to load [\"+factoryClass.getName()+\"] factories from location [\"+FACTORIES_RESOURCE_LOCATION+\"]\",ex);\r\n	 \r\n	}\r\n\r\n}\r\n这个方法会加载类路径及所有jar包下META-INF/spring.factories配置中映射的自动配置的类。\r\n\r\n/**\r\n\r\n * The location to look for factories.\r\n\r\n * <p>Can be present in multiple JAR files.\r\n   */\r\n\r\npublic static final String FACTORIES_RESOURCE_LOCATION = \"META-INF/spring.factories\";\r\n查看Spring Boot自带的自动配置的包： spring-boot-autoconfigure-1.5.6.RELEASE.jar，打开其中的META-INF/spring.factories文件会找到自动配置的映射。\r\n\r\n\r\n\r\n再来看看数据源自动配置的实现注解\r\n\r\n\r\n\r\n@Configuration,@ConditionalOnClass就是自动配置的核心，首先它得是一个配置文件，其次根据类路径下是否有这个类去自动配置。\r\n\r\n \r\n\r\nSpring Boot 的目录结构是怎样的？\r\nSpring Boot 与传统项目最大的区别是，传统项目都是打成 WAR 包部署到服务器上面，需要额外的 Servlet 容器， 而 Spring Boot 则可以直接打成 jar包，并内置集成了 Servlet 容器，通过命令 java -jar xx.jar 则可以直接运行，不需要独立的 Servlet 容器。\r\n\r\n打成可执行 jar 包后，我们来看下其中的 META-INF/MANIFEST.MF 文件：\r\n\r\n\r\n\r\n其中有一个 Start-Class 便是这个 jar 包的入口类，这个入口类推荐是放在一个项目的顶层包中，其他所有的类都放在其子包下面，目录结构如以下所示：\r\n\r\n\r\n\r\n这个目录结构是主流及推荐的做法，而在主入口类上加上 @SpringBootApplication 注解来开启 Spring Boot 的各项能力，如自动配置、组件扫描等。\r\n\r\n\r\n\r\n如果你不想这么做，你也可以充分利用 @EnableAutoConfiguration 和 @ComponentScan 注解自定义你的行为，不过这不是推荐的做法。\r\n\r\n \r\n\r\n你如何理解 Spring Boot 中的 Starters？\r\nStarters是什么：\r\n\r\nStarters可以理解为启动器，它包含了一系列可以集成到应用里面的依赖包，你可以一站式集成Spring及其他技术，而不需要到处找示例代码和依赖包。如你想使用Spring JPA访问数据库，只要加入spring-boot-starter-data-jpa启动器依赖就能使用了。Starters包含了许多项目中需要用到的依赖，它们能快速持续的运行，都是一系列得到支持的管理传递性依赖。\r\n\r\nStarters命名：\r\n\r\nSpring Boot官方的启动器都是以spring-boot-starter-命名的，代表了一个特定的应用类型。第三方的启动器不能以spring-boot开头命名，它们都被Spring Boot官方保留。一般一个第三方的应该这样命名，像mybatis的mybatis-spring-boot-starter。\r\n\r\nStarters分类：\r\n\r\n \r\n\r\n1. Spring Boot应用类启动器\r\n\r\n\r\n\r\n2. Spring Boot生产启动器\r\n\r\n\r\n\r\n3. Spring Boot技术类启动器\r\n\r\n\r\n\r\n4. 其他第三方启动器\r\n\r\n \r\n\r\n如何在 Spring Boot 启动的时候运行一些特定的代码？\r\n如果你想在Spring Boot启动的时候运行一些特定的代码，你可以实现接口ApplicationRunner或者CommandLineRunner，这两个接口实现方式一样，它们都只提供了一个run方法。\r\n\r\nCommandLineRunner：启动获取命令行参数\r\n\r\n\r\n\r\nApplicationRunner：启动获取应用启动的时候参数\r\n\r\n\r\n\r\n使用方式：\r\n\r\n\r\n\r\n或者这样\r\n\r\n\r\n\r\n启动顺序：\r\n\r\n如果启动的时候有多个ApplicationRunner和CommandLineRunner，想控制它们的启动顺序，可以实现 org.springframework.core.Ordered接口或者使用 org.springframework.core.annotation.Order注解。\r\n\r\n \r\n\r\nSpring Boot 有哪几种读取配置的方式？\r\n读取application文件：\r\n\r\n在application.yml或者properties文件中添加：\r\n\r\ninfo.address=USA\r\n\r\ninfo.company=Spring\r\n\r\ninfo.degree=high\r\n\r\n一、@Value注解读取方式：\r\n\r\n\r\n\r\n二、@ConfigurationProperties注解读取方式：\r\n\r\n\r\n\r\n读取指定文件：\r\n\r\n资源目录下建立config/db-config.properties:\r\n\r\ndb.username=root\r\n\r\ndb.password=123456\r\n\r\n一、@PropertySource+@Value注解读取方式：\r\n\r\n\r\n\r\n注意：@PropertySource不支持yml文件读取。\r\n\r\n二、@PropertySource+@ConfigurationProperties注解读取方式：\r\n\r\n\r\n\r\n三、Environment读取方式：\r\n\r\n以上所有加载出来的配置都可以通过Environment注入获取到：\r\n\r\n\r\n\r\n \r\n\r\n总结\r\n\r\n从以上示例来看，Spring Boot可以通过@PropertySource,@Value,@Environment,@ConfigurationProperties来绑定变量。\r\n\r\n \r\n\r\nSpring Boot 支持哪些日志框架？推荐和默认的日志框架是哪个？\r\nSpring Boot支持Java Util Logging,Log4j2,Lockback作为日志框架，如果你使用starters启动器，Spring Boot将使用Logback作为默认日志框架。无论使用哪种日志框架，Spring Boot都支持配置将日志输出到控制台或者文件中。\r\n\r\nspring-boot-starter启动器包含spring-boot-starter-logging启动器并集成了slf4j日志抽象及Logback日志框架。\r\n\r\n属性配置日志：\r\n\r\nSpring Boot支持属性配置日志参数，这个不是很灵活，不细讲。\r\n\r\n参考配置：\r\n\r\n\r\n\r\n如：\r\n\r\n\r\n\r\n自定义日志文件：\r\n\r\n根据不同的日志框架，默认加载的日志配置文件的文件名，放在资源根目录下，其他的目录及文件名不能被加载。\r\n\r\n\r\n\r\n既然默认自带了Logback框架，Logback也是最优秀的日志框架，往资源目录下创建一个logback-spring.xml即可。\r\n\r\n强烈推荐使用logback-spring.xml作为文件名，因为logback.xml加载太早。\r\n\r\n日志初始化在ApplicationContext创建之前，所以@PropertySources加载的配置是读取不到的，系统环境变量、Spring Environment及application，bootstrap配置文件中的信息可以读取到。\r\n\r\n读取系统环境属性：\r\n\r\n\r\n\r\n读取当前应用Environment中的属性：\r\n\r\n\r\n\r\nSpring Boot也支持通过springProfile来加载不同profiles下的配置：\r\n\r\n\r\n\r\n \r\n\r\nSpringBoot 实现热部署有哪几种方式？\r\n在Spring Boot实现代码热部署是一件很简单的事情，代码的修改可以自动部署并重新热启动项目。\r\n\r\n一、引用devtools依赖：\r\n\r\n\r\n\r\n这样，当修改一个java类时就会热更新。\r\n\r\n二、自定义配置热部署：\r\n\r\n以下配置用于自定义配置热部署，可以不设置。\r\n\r\n\r\n\r\n三、Intellij Idea修改：\r\n\r\n如果是idea，需要改以下两个地方：\r\n\r\n1、勾上自动编译或者手动重新编译\r\n\r\nFile > Settings > Compiler-Build Project automatically\r\n\r\n2、注册\r\n\r\nctrl + shift + alt + / > Registry > 勾选Compiler autoMake allow when app running\r\n\r\n注意事项：\r\n\r\n1、生产环境devtools将被禁用，如java -jar方式或者自定义的类加载器等都会识别为生产环境。\r\n\r\n2、打包应用默认不会包含devtools，除非你禁用SpringBoot Maven插件的excludeDevtools属性。\r\n\r\n3、Thymeleaf无需配置 spring.thymeleaf.cache:false，devtools默认会自动设置，参考完整属性。\r\n\r\n下面是devtools自动配置的部分源码：\r\n\r\n\r\n\r\n4、devtools会在windows资源管理器占用java进程，在开发工具里面杀不掉，只能手动kill掉，不然重启会选成端口重复绑定报错。\r\n\r\n \r\n\r\n你如何理解 Spring Boot 配置加载顺序？\r\n使用 Spring Boot 会涉及到各种各样的配置，如开发、测试、线上就至少 3 套配置信息了。Spring Boot 可以轻松的帮助我们使用相同的代码就能使开发、测试、线上环境使用不同的配置。\r\n\r\n在 Spring Boot 里面，可以使用以下几种方式来加载配置：\r\n\r\n1、properties文件；\r\n\r\n2、YAML文件；\r\n\r\n3、系统环境变量；\r\n\r\n4、命令行参数；\r\n\r\n等等……\r\n\r\n配置属性加载的顺序如下：\r\n\r\n1、开发者工具 `Devtools` 全局配置参数；\r\n\r\n2、单元测试上的 `@TestPropertySource` 注解指定的参数；\r\n\r\n3、单元测试上的 `@SpringBootTest` 注解指定的参数；\r\n\r\n4、命令行指定的参数，如 `java -jar springboot.jar --name=\"Java技术栈\"`；\r\n\r\n5、命令行中的 `SPRING_APPLICATION_JSONJSON` 指定参数, 如 `java -Dspring.application.json=\'{\"name\":\"Java技术栈\"}\' -jar springboot.jar`\r\n\r\n6、`ServletConfig` 初始化参数；\r\n\r\n7、`ServletContext` 初始化参数；\r\n\r\n8、JNDI参数（如 `java:comp/env/spring.application.json`）；\r\n\r\n9、Java系统参数（来源：`System.getProperties()`）；\r\n\r\n10、操作系统环境变量参数；\r\n\r\n11、`RandomValuePropertySource` 随机数，仅匹配：`ramdom.*`；\r\n\r\n12、JAR包外面的配置文件参数（`application-{profile}.properties（YAML）`）\r\n\r\n13、JAR包里面的配置文件参数（`application-{profile}.properties（YAML）`）\r\n\r\n14、JAR包外面的配置文件参数（`application.properties（YAML）`）\r\n\r\n15、JAR包里面的配置文件参数（`application.properties（YAML）`）\r\n\r\n16、`@Configuration`配置文件上 `@PropertySource` 注解加载的参数；\r\n\r\n17、默认参数（通过 `SpringApplication.setDefaultProperties` 指定）；\r\n数字小的优先级越高，即数字小的会覆盖数字大的参数值，我们来实践下，验证以上配置参数的加载顺序。\r\n\r\n1、在主应用程序中添加 Java 系统参数\r\n\r\n\r\n\r\n2、在 application.properties 文件中添加属性\r\n\r\n\r\n\r\n3、在 application-dev.properties 文件中添加属性\r\n\r\n\r\n\r\n4、添加测试类\r\n\r\n\r\n\r\n运行 test 单元测试，程序输出：\r\n\r\n\r\n\r\n \r\n\r\nSpring Boot 如何定义多套不同环境配置？\r\n首先我们要了解一个名词：Profile\r\n\r\n简单来说，Profile就是Spring Boot可以对不同环境或者指令来读取不同的配置文件。\r\n\r\n假如有开发、测试、生产三个不同的环境，需要定义三个不同环境下的配置。\r\n\r\n基于properties文件类型\r\n\r\n你可以另外建立3个环境下的配置文件：\r\n\r\napplcation.properties\r\n\r\napplication-dev.properties\r\n\r\napplication-test.properties\r\n\r\napplication-prod.properties\r\n\r\n然后在applcation.properties文件中指定当前的环境spring.profiles.active=test，这时候读取的就是application-test.properties文件。\r\n\r\n基于yml文件类型\r\n\r\n只需要一个applcation.yml文件就能搞定，推荐此方式。\r\n\r\n\r\n\r\n此时读取的就是prod的配置，prod包含proddb,prodmq，此时可以读取proddb,prodmq下的配置。\r\n\r\n也可以同时激活三个配置。\r\n\r\n\r\n\r\n基于Java代码\r\n\r\n在JAVA配置代码中也可以加不同Profile下定义不同的配置文件，@Profile注解只能组合使用@Configuration和@Component注解。\r\n\r\n\r\n\r\n指定Profile\r\n\r\nmain方法启动方式：\r\n\r\n\r\n\r\n插件启动方式：\r\n\r\n\r\n\r\njar运行方式：\r\n\r\n\r\n\r\n除了在配置文件和命令行中指定Profile，还可以在启动类中写死指定，通过SpringApplication.setAdditionalProfiles方法。\r\n\r\nSpringApplication.class：\r\n\r\n\r\n\r\n \r\n\r\nSpring Boot 可以兼容老 Spring 项目吗，如何做？\r\n可以兼容，使用 @ImportResource 注解导入老 Spring 项目配置文件。\r\n\r\n \r\n\r\n保护 Spring Boot 应用有哪些方法？\r\n1.在生产中使用HTTPS\r\n2.使用Snyk检查你的依赖关系\r\n3.升级到最新版本\r\n4.启用CSRF保护\r\n5.使用内容安全策略防止XSS攻击\r\n6.使用OpenID Connect进行身份验证\r\n7.管理密码？使用密码哈希！\r\n8.安全地存储秘密\r\n9.使用OWASP的ZAP测试您的应用程序\r\n10.让你的安全团队进行代码审查\r\n\r\n更多请看这篇文章《10 种保护 Spring Boot 应用的绝佳方法》。\r\n\r\n \r\n\r\nSpring Boot 2.X 有什么新特性？与 1.X 有什么区别？\r\n配置变更\r\nJDK 版本升级\r\n第三方类库升级\r\n响应式 Spring 编程支持\r\nHTTP/2 支持\r\n配置属性绑定\r\n更多改进与加强...\r\n具体请看这篇文章《Spring Boot 2.x 新特性总结及迁移指南》。\r\n\r\n \r\n\r\nJavaBean是什么时候创建的？\r\n在项目里面写一个bean：\r\n\r\n@Controller\r\npublic class TestController {\r\n    public TestController(){\r\n        System.out.println(\"TestController 创建了\");\r\n    }\r\n}\r\n1.直接启动，通过日志可以看到TestController 被创建了\r\n\r\n2018-07-02 17:38:58.083  INFO 7076 --- [ost-startStop-1] o.s.b.w.servlet.ServletRegistrationBean  : Mapping servlet: \'dispatcherServlet\' to [/]\r\n2018-07-02 17:38:58.088  INFO 7076 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: \'characterEncodingFilter\' to: [/*]\r\n2018-07-02 17:38:58.088  INFO 7076 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: \'hiddenHttpMethodFilter\' to: [/*]\r\n2018-07-02 17:38:58.089  INFO 7076 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: \'httpPutFormContentFilter\' to: [/*]\r\n2018-07-02 17:38:58.089  INFO 7076 --- [ost-startStop-1] o.s.b.w.servlet.FilterRegistrationBean   : Mapping filter: \'requestContextFilter\' to: [/*]\r\nTestController 创建了\r\n2018-07-02 17:38:58.483  INFO 7076 --- [           main] s.w.s.m.m.a.RequestMappingHandlerAdapter : Looking for @ControllerAdvice: org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext@78dd667e: startup date [Mon Jul 02 17:38:55 CST 2018]; root of context hierarchy\r\n2018-07-02 17:38:58.558  INFO 7076 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"{[/error]}\" onto public org.springframework.http.ResponseEntity<java.util.Map<java.lang.String, java.lang.Object>> org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)\r\n2018-07-02 17:38:58.559  INFO 7076 --- [           main] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped \"{[/error],produces=[text/html]}\" onto public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)\r\n2018-07-02 17:38:58.587  INFO 7076 --- [           main] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/webjars/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]\r\n2018-07-02 17:38:58.587  INFO 7076 --- [           main] o.s.w.s.handler.SimpleUrlHandlerMapping  : Mapped URL path [/**] onto handler of type [class org.springframework.web.servlet.resource.ResourceHttpRequestHandler]\r\n2.设置断点进行调试\r\n\r\n这一步是关键的，在进行操作的时候，可根据自己的情况进行断点调试，这边给出几个推荐的断点位置\r\n\r\n断点一：启动位置\r\n\r\npublic class App {\r\n    public static void main(String[] args) {\r\n        SpringApplication.run(App.class,args);\r\n    }\r\n}\r\n断点二： run 方法内部 \r\n\r\npublic ConfigurableApplicationContext run(String... args) {\r\n        StopWatch stopWatch = new StopWatch();\r\n        stopWatch.start();\r\n        ConfigurableApplicationContext context = null;\r\n        FailureAnalyzers analyzers = null;\r\n        configureHeadlessProperty();\r\n        SpringApplicationRunListeners listeners = getRunListeners(args);\r\n        listeners.starting();\r\n        try {\r\n            ApplicationArguments applicationArguments = new DefaultApplicationArguments(\r\n                    args);\r\n            ConfigurableEnvironment environment = prepareEnvironment(listeners,\r\n                    applicationArguments);\r\n            Banner printedBanner = printBanner(environment);\r\n            context = createApplicationContext();\r\n            analyzers = new FailureAnalyzers(context);\r\n            prepareContext(context, environment, listeners, applicationArguments,\r\n                    printedBanner);\r\n            refreshContext(context);\r\n            afterRefresh(context, applicationArguments);\r\n            listeners.finished(context, null);\r\n            stopWatch.stop();\r\n            if (this.logStartupInfo) {\r\n                new StartupInfoLogger(this.mainApplicationClass)\r\n                        .logStarted(getApplicationLog(), stopWatch);\r\n            }\r\n            return context;\r\n        }\r\n        catch (Throwable ex) {\r\n            handleRunFailure(context, listeners, analyzers, ex);\r\n            throw new IllegalStateException(ex);\r\n        }\r\n    }\r\n该方法就是Spring Boot项目启动时 所要执行的代码，根据阅读可以分为以下步骤： \r\n\r\n1. 加载环境变量 \r\n2. 创建上下文 ConfigurableApplicationContext 对象 \r\n3. 准备上下文 prepareContext() \r\n4. 刷新上下文 refreshContext() \r\n5. 刷新之后的处理 afterRefresh() \r\n\r\n可以在以上的五个地方进行断点设置，然后开始调试,结合控制台的日志一步一步观察。\r\n\r\n通过断点调试，发现执行完refreshContext()方法执行完毕之后，日志打印了：\r\n\r\nTestController 创建了\r\n初步判断，Bean在执行refreshContext() 方法的时候创建的，那么接下来我们看一下refreshContext这个方法干了什么事情？\r\n\r\n断点三： \r\n进入refreshContext 方法，找到最终调用的方法 refresh()\r\n\r\n    @Override\r\n    public void refresh() throws BeansException, IllegalStateException {\r\n        synchronized (this.startupShutdownMonitor) {\r\n            // Prepare this context for refreshing.\r\n            prepareRefresh();\r\n     \r\n            // Tell the subclass to refresh the internal bean factory.\r\n            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();\r\n     \r\n            // Prepare the bean factory for use in this context.\r\n            prepareBeanFactory(beanFactory);\r\n     \r\n            try {\r\n                // Allows post-processing of the bean factory in context subclasses.\r\n                postProcessBeanFactory(beanFactory);\r\n     \r\n                // Invoke factory processors registered as beans in the context.\r\n                invokeBeanFactoryPostProcessors(beanFactory);\r\n     \r\n                // Register bean processors that intercept bean creation.\r\n                registerBeanPostProcessors(beanFactory);\r\n     \r\n                // Initialize message source for this context.\r\n                initMessageSource();\r\n     \r\n                // Initialize event multicaster for this context.\r\n                initApplicationEventMulticaster();\r\n     \r\n                // Initialize other special beans in specific context subclasses.\r\n                onRefresh();\r\n     \r\n                // Check for listener beans and register them.\r\n                registerListeners();\r\n     \r\n                // Instantiate all remaining (non-lazy-init) singletons.\r\n                finishBeanFactoryInitialization(beanFactory);\r\n     \r\n                // Last step: publish corresponding event.\r\n                finishRefresh();\r\n            }\r\n\r\n以步骤二的断点设置方式，我们在进行一步调试，发现执行finishBeanFactoryInitialization(beanFactory)方法之后，日志打印了\r\n\r\nTestController 创建了\r\n该方法的具体实现如下：\r\n\r\nprotected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {\r\n        // Initialize conversion service for this context.\r\n        if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &&\r\n                beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {\r\n            beanFactory.setConversionService(\r\n                    beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));\r\n        }\r\n\r\n        // Register a default embedded value resolver if no bean post-processor\r\n        // (such as a PropertyPlaceholderConfigurer bean) registered any before:\r\n        // at this point, primarily for resolution in annotation attribute values.\r\n        if (!beanFactory.hasEmbeddedValueResolver()) {\r\n            beanFactory.addEmbeddedValueResolver(new StringValueResolver() {\r\n                @Override\r\n                public String resolveStringValue(String strVal) {\r\n                    return getEnvironment().resolvePlaceholders(strVal);\r\n                }\r\n            });\r\n        }\r\n     \r\n        // Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.\r\n        String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);\r\n        for (String weaverAwareName : weaverAwareNames) {\r\n            getBean(weaverAwareName);\r\n        }\r\n     \r\n        // Stop using the temporary ClassLoader for type matching.\r\n        beanFactory.setTempClassLoader(null);\r\n     \r\n        // Allow for caching all bean definition metadata, not expecting further changes.\r\n        beanFactory.freezeConfiguration();\r\n     \r\n        // Instantiate all remaining (non-lazy-init) singletons.\r\n        beanFactory.preInstantiateSingletons();\r\n    }\r\n\r\n通过调试我们可以发现，执行beanFactory.preInstantiateSingletons();这个方法之后，TestController 被创建了，那么我接下来要做的就是看这个方法具体怎么实现的，调试过程中，我们通过shift+alt+F7 强制进入代码，可以看到其具体实现如下：\r\n\r\n@Override\r\n    public void preInstantiateSingletons() throws BeansException {\r\n        if (this.logger.isDebugEnabled()) {\r\n            this.logger.debug(\"Pre-instantiating singletons in \" + this);\r\n        }\r\n\r\n        // Iterate over a copy to allow for init methods which in turn register new bean definitions.\r\n        // While this may not be part of the regular factory bootstrap, it does otherwise work fine.\r\n        List<String> beanNames = new ArrayList<String>(this.beanDefinitionNames);\r\n     \r\n        // Trigger initialization of all non-lazy singleton beans...\r\n        for (String beanName : beanNames) {\r\n            RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);\r\n            if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {\r\n                if (isFactoryBean(beanName)) {\r\n                    final FactoryBean<?> factory = (FactoryBean<?>) getBean(FACTORY_BEAN_PREFIX + beanName);\r\n                    boolean isEagerInit;\r\n                    if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {\r\n                        isEagerInit = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {\r\n                            @Override\r\n                            public Boolean run() {\r\n                                return ((SmartFactoryBean<?>) factory).isEagerInit();\r\n                            }\r\n                        }, getAccessControlContext());\r\n                    }\r\n                    else {\r\n                        isEagerInit = (factory instanceof SmartFactoryBean &&\r\n                                ((SmartFactoryBean<?>) factory).isEagerInit());\r\n                    }\r\n                    if (isEagerInit) {\r\n                        getBean(beanName);\r\n                    }\r\n                }\r\n                else {\r\n                    getBean(beanName);\r\n                }\r\n            }\r\n        }\r\n     \r\n        // Trigger post-initialization callback for all applicable beans...\r\n        for (String beanName : beanNames) {\r\n            Object singletonInstance = getSingleton(beanName);\r\n            if (singletonInstance instanceof SmartInitializingSingleton) {\r\n                final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;\r\n                if (System.getSecurityManager() != null) {\r\n                    AccessController.doPrivileged(new PrivilegedAction<Object>() {\r\n                        @Override\r\n                        public Object run() {\r\n                            smartSingleton.afterSingletonsInstantiated();\r\n                            return null;\r\n                        }\r\n                    }, getAccessControlContext());\r\n                }\r\n                else {\r\n                    smartSingleton.afterSingletonsInstantiated();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n采用调试的方式，通过观察我们可以看到，我们的TestController Bean 被加载到beanNames这个List，通过循环语句最终调用了getBean(beanName);去创建了对象，当然getBean内部会调用doGetBean() 方法进行对象的获取或者创建。\r\n\r\n总结\r\n\r\nTestController 这个对象的创建，经过了如下方法调用：\r\n\r\nSpringApplication.run(App.class,args) \r\nrefreshContext(context) \r\nfinishBeanFactoryInitialization(beanFactory) \r\nbeanFactory.preInstantiateSingletons() \r\ngetBean(beanName) \r\ndoGetBean()\r\n\r\n \r\n\r\nSpringBoot框架中，JavaBean都是单例的吗？多例怎么设置？\r\nspring bean作用域有以下5个：\r\n\r\nsingleton：单例模式，当spring创建applicationContext容器的时候，spring会欲初始化所有的该作用域实例，加上lazy-init就可以避免预处理；\r\n\r\nprototype：原型模式，每次通过getBean获取该bean就会新产生一个实例，创建后spring将不再对其管理；\r\n\r\n====下面是在web项目下才用到的===\r\n\r\nrequest：搞web的大家都应该明白request的域了吧，就是每次请求都新产生一个实例，和prototype不同就是创建后，接下来的管理，spring依然在监听；\r\n\r\nsession：每次会话，同上；\r\n\r\nglobal session：全局的web域，类似于servlet中的application。\r\n\r\n好了，上面都说了spring的controller默认是单例，那很自然就是singleton了。\r\n\r\n为什么spring要默认是单例呢？原因有二：\r\n\r\n1、为了性能：这个不用废话了，单例不用每次都new，当然快了。\r\n\r\n2、不需要多例：不需要多例会让很多人迷惑，因为spring mvc官方也没明确说不可以多例。\r\n\r\n我这里说不需要的原因是看开发者怎么用了，如果你给controller中定义很多的属性，那么单例肯定会出现竞争访问了。\r\n\r\n因此，只要controller中不定义属性，那么单例完全是安全的。下面给个例子说明下：\r\n\r\n@Controller\r\npublic class MultViewController {   \r\n    private int index = 0;//非静态\r\n    @RequestMapping(\"/show\")\r\n    public String toShow(ModelMap model) {\r\n        System.out.println(++i);\r\n        return\"show\";\r\n    }\r\n    @RequestMapping(\"/test\")\r\n    public String test() {\r\n        System.out.println(++i);\r\n        return\"test\";\r\n    }\r\n}\r\n从此可见，单例是不安全的，会导致属性重复使用。\r\n\r\n1、不要在controller中定义成员变量。\r\n\r\n2、万一必须要定义一个非静态成员变量时候，则通过注解**@Scope(\"prototype\")**，将其设置为多例模式。', 1589630038212, 1589630035513, 29, 1, 7, 0, 'java,spring,tomcat', 'https://avatars2.githubusercontent.com/u/52100840?v=4');
INSERT INTO `question` VALUES (174, '图上哪里报错呢', '代码格式：\r\n```java\r\n@RequestMapping(\"/question/{id}\")\r\n    public String toUpdateQuestion(@PathVariable(name = \"id\") Long id,Model model){\r\n        QuestionDTO question = questionService.getQuestionById(id);\r\n        model.addAttribute(\"title\",question.getTitle());\r\n        model.addAttribute(\"description\",question.getDescription());\r\n        model.addAttribute(\"tag\",question.getTag());\r\n        model.addAttribute(\"tags\", TagCache.get());\r\n        return \"question\";\r\n    }\r\n```\r\n图片：\r\n![](/images/img/test01.png)', 1590712926017, 1590713715441, 29, 1, 23, 0, 'java', 'https://avatars2.githubusercontent.com/u/52100840?v=4');

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `ID` bigint(11) NOT NULL AUTO_INCREMENT,
  `ACCOUNT_ID` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `NAME` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  `TOKEN` char(36) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `GMT_CREATE` bigint(20) NULL DEFAULT NULL,
  `GMT_MODIFIED` bigint(20) NULL DEFAULT NULL,
  `LOGIN` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `avatar_url` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL,
  PRIMARY KEY (`ID`, `TOKEN`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 31 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES (29, '52100840', '小生阿明', '6a056636-e6bc-44f8-a83d-822355f1e22e', 1589391729150, 1602155960470, 'Ming927', 'https://avatars2.githubusercontent.com/u/52100840?v=4');
INSERT INTO `user` VALUES (30, '57753360', '阿明', '28921ad8-ae2f-40bf-a503-07e97f327f5d', 1589392690391, 1589724754114, 'xiaoming1011024', 'https://avatars2.githubusercontent.com/u/57753360?v=4');

SET FOREIGN_KEY_CHECKS = 1;
